{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to rToken\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs -h\n - Print help message and exit.\n\n\n\n\nTESTING\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-rtoken",
            "text": "For full documentation visit  mkdocs.org .",
            "title": "Welcome to rToken"
        },
        {
            "location": "/#commands",
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs -h  - Print help message and exit.   TESTING",
            "title": "Commands"
        },
        {
            "location": "/#project-layout",
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Project layout"
        },
        {
            "location": "/elements/",
            "text": "Elements\n\n\n\n\nrTokens\n\n\nrTokens are wrapped versions of underlying ERC20 assets that earn interest that can be redirected to flow to recipients that the holder of the underlying asset chooses.\n\n\nThe rToken contract keeps track of the total amount of minted rTokens, user balances, and User Buckets. \n\n\nDeployment\n\n\nAt deployment, an rToken contract must specify the address of the underlying ERC20 asset. To be useful as an rToken, the underlying ERC20 asset should be available to supply on one or more  platforms for which an Allocation Strategy has been written to manage and redirect interest.\n\n\nrToken Accounts\n\n\nEach address has an rToken Account. The account data includes:\n\nuserBuckets\n \u2013 an array specifying the amounts of rTokens committed to each active \nhatID\n\ninternal accounting information,\naccount statistics.\n\n\nMinting\n\n\nrTokens are minted and redeemed at a ratio of 1:1 to their underlying asset. So 25 DAI can mint 25 rDAI, which are then redeemable for 25 DAI.\n\n\nLike other ERC20 wrapper contracts, rToken contracts require holders of the underlying asset to \napprove\n the amount of the asset to be used to mint rTokens. This amount can be queried with \nallowance\n.\n\n\nThere are three minting functions:\n\n\n\n\n\n\nmint(uint256 amount)\n - \n\n\n\n\n\n\nmintWithSelectedHat(uint256 amount uint256 hatID)\n - \n\n\n\n\n\n\nControl Over Interest Streams\n\n\nThe holder of the underlying asset remains in control of where the interest streams flow, but cannot claw back interest that has already been redirected. The holder can stop sending interest to a recipient (or recipients) by: 1) redeeming all the principal for the underlying asset or 2) changing the set of recipients with the \nchangeHat\n function. \n\n\nAccounting Construct\n\n\nrTokens work by recording the amount of the underlying asset that an address mints (the principal) as a fixed debt that must be repaid, and then \u201clending\u201d out the now interest earning principal to the interest recipients. The recipients can redeem the amount of rTokens that have accrued from interest, but they cannot redeem the debt portion which represents the principal.\n\n\nExample\n\n\n\n\nAlice mints 1,000 rDAI and designates Bob as the only interest recipient. \n\n\nAt that time Bob has received a loan of 1,000 rDAI and a debt to repay 1,000 rDAI to Alice, meaning a net position of 0 rDAI.  \n\n\nIf Bob calls redeemAll() to try to get all the underlying DAI, he will not receive anything because he can only redeem the amount in excess of the debt. \n\n\nNow fast forward to a time when 75 DAI in interest has accumulated. Bob's \u201cloan\u201d is now worth 1,075 DAI but his debt remains 1,000 DAI, so he can redeem 75 DAI.   \n\n\n\n\nCommon write functions\n\n\nInitialize\n\n\n\n\ninitialize(address underlyingAsset, string memory name_, string memory symbol_, uint256 decimals_) public\n \u2013 set the parameters of an rToken at deployment\n\n\n\n\nApprove\n\n\napprove(address owner address spender) external public returns (bool)\n - allow rToken minting from underlying ERC20 asset\n\n\nMinting\n\n\n\n\n\n\nmint(uint256 mintAmount) external nonReentrant returns (bool)\n - swap underlying asset for rTokens at 1:1 ratio, e.g. \nmint\n 100 rDAI from 100 DAI - by default, will send interest to minter's address \n\n\n\n\n\n\nmintWithSelectedHat(uint256 mintAmount, uint256 hatID) external nonReentrant returns (bool)\n - mint rTokens into specified \nhatID\n \n\n\n\n\n\n\nmintWithNewHat(uint256 mintAmount, address[] calldata recipients, uint32[] calldata proportions) external nonReentrant returns (bool)\n - create a new hat and mint rTokens into that \nhatID\n\n\n\n\n\n\nNEW FOR V2 \nmintWithUserBuckets(uint256 mintAmount) external nonReentrant returns (bool)\n - same as \nmint\n except the newly minted rTokens will increase all \nuserBucket\n balances proportionally - can be gas-inefficient  \n\n\n\n\n\n\nRedemption\n\n\n\n\n\n\nredeem(uint256 redeemAmount) external nonReentrant returns (bool)\n - redeem specified rTokens for underlying ERC20 asset at 1:1 ratio\n\n\n\n\n\n\nredeemAll() external nonReentrant returns (bool)\n - redeem all rTokens for underlying ERC20 asset at 1:1 ratio\n\n\n\n\n\n\nTransfers\n\n\n\n\n\n\ntransfer(address dst, uint256 amount) external nonReentrant returns (bool)\n - standard ERC20 transfer function  \n\n\n\n\n\n\ntransferAll(address dst) external nonReentrant returns (bool)\n - standard ERC20 transferAll function - can be gas inefficient if userBuckets include multiple allocation strategies\n\n\n\n\n\n\nClaiming Accrued Interest\n\n\n\n\npayInterest(address )\n\n\n\n\nChanging Hats\n\n\n\n\n\n\nchangeHatForBucket(uint256 newHatID, uint32 bucket) external nonReentrant returns (bool)\n\n\n\n\n\n\nchangeHatForAllBuckets(uint256 newHatID) external nonReentrant returns (bool)\n\n\n\n\n\n\nCommon read functions\n\n\n\n\n\n\ngetHatsByAddress(address owner) external view returns (hats[])\n\n\n\n\n\n\ngetBucketsByAddress(address owner) external view returns (userBuckets[])\n\n\n\n\n\n\nreceivedSavingsOf(address owner) external view returns (uint256 amount)\n\n\n\n\n\n\nreceivedLoanOf(address owner) external view returns (uint256 amount)\n\n\n\n\n\n\ninterestPayableOf(address owner) external view returns (uint256 amount)\n\n\n\n\n\n\ngetUnderlyingAsset() public view returns (address)\n\n\n\n\n\n\nbalanceOf(address owner) external view returns (uint256 amount)\n\n\n\n\n\n\nallowance(address owner, address spender) external view returns (uint256)\n \n\n\n\n\n\n\n\n\nHats\n\n\nHats contain the instructions for where to generate and redirect the interest on rTokens. Each hat specifies to which addresses the interest should flow and in what proportions, where the underlying asset should be invested to earn interest, and if the hat can be changed, by who. \nHats are ERC721 NFTs.\n\n\nHat Parameters\n\n\nA hat contains the following four parameters:\n\n\nrecipients\n - an array of up to 50 addresses where the interest should flow\n\n\nproportions\n - an array specifying the proportion of the interest each recipient should receive \u2013 this array must have the same length as \nrecipients\n\n\nallocationStrategy\n - an address (enum?) specifying the liquidity pool to deposit the underlying asset to earn interest from (e.g. Compound, Aave, etc)\n\n\nmanager\n - an address specifying who can modify the hat's parameters \u2013 can be set to the 0x000... address to make a hat immutable\n\n\nThe parameters \nrecipients\n and \nproportions\n are the central programmable components of rToken interest. The number of recipients in a hat can be just one or up to 50 (this maximum number is there to avoid a possible out-of-gas reversion error).  Proportions can be set arbitrarily and the contract will allocate the interest as a proportion of the maximum uint32 number (4,294,967,295 in decimal), so if the proportions entered were  [1, 2, 3, 4] meaning the fourth recipient received 4x the interest as the first, the \nproportions\n stored on chain would be [429496730, 858993459, 1288490188, 1717986918].\n\n\nThe \nallocationStrategy\n parameter points to the address of the deployed contract that invests the underlying asset in a particular lending protocol, such as Compound's cTokens or Aave's aTokens. \n\n\nThe \nmanager\n parameter will typically be the creator of a hat that others might want to use, such as a charity dapp.  The manager has the power to modify the other three parameters of the hat - \nrecipients\n \nproportions\n and \nallocationStrategy\n - pursuant to the rules surrounding modifying hats (link). \n\n\nNone of the hat parameters are exclusive, either separately or together \u2013 there are no squatter's rights to being the first manager for a potentially popular combination of \nrecipients\n, \nproportions\n and \nallocationStrategy.\n \n\n\nChangeable Hats\n\n\nChangeable hats have several substantive use cases, including allowing trusted dapp managers to be able to redirect interest to better serve their users' ends, to swap out of an underperforming lending pool to obtain higher yields or to switch to a more stable/liquid lending pool.rToken-powered dapps would otherwise require each user to manually change hats whenever it recommended a different set of parameters.  Changeable hats do introduce a potential for abuse by the managers, but because changes are emitted as events, malicious managers cannot act in stealth, nor do they have any control over the holder's principal assets, only forward looking interest streams.\n\n\nImmutable Hats\n\n\nThere may be use cases where hat immutability is desirable to prevent the possibility of mismanagement. Immutable hats can be created by assigning the burn address (0x0000000000000000000000000000000000000000) in the \nmanager\n parameter. \n\n\n\n\nUser Buckets\n\n\nUser Buckets, added for rToken V2, are tranches of rTokens assigned to a particular Hat. A bucket can contain some or all of the user's rToken balance.  Buckets are a design solution to the \u201chat yanking\u201d problem described here[https://medium.com/rtoken-project/rdai-v2-the-redirectening-90b6a9115799].  \n\n\nEach rToken holder has a \nuserBuckets\n array with each slot specifying the \nhatID\n and the \namount\n of the rToken used in that Hat. The first array position (slot 0) is reserved as a self-hat that redirects the interest to the user, similar to directly lending assets in a liquidity pool. \n\n\nUser Buckets are created and maintained automatically within the rToken contract.\n\n\nExample\n\n\n\n\nAssume Alice mints 100 rDAI, and donates the interest on 40 rDAI to Charity X. \n\n\nHer \nuserBuckets\n array now contains two slots, with the self-hat slot 0 holding \namount: 60\n and slot 1 pointing to \nhatID: [Hat with Charity X address]\n holding \namount: 40\n. \n\n\nLater Alice decides to send the interest on the remaining 60 rDAI to Charity Y.  \n\n\nNow \nuserBuckets\n has three slots with \namount\n 0, 40 and 60 respectively.\n\n\n[TBD: when a user redeems the amount in a bucket, is that \nuserBuckets\n array slot deleted  or preserved with a 0 \namount\n? Preserving old buckets might lead to state bloat, but might be useful for historical accounting purposes. Deleting buckets could reduce state size, but may lead to complications if dapps or other entities seek to query particular hat/bucket data based on slot position]\n\n\n\n\nCommon read functions\n\n\ngetUserBuckets(address owner) public view returns []\n - returns an array containing the address' \nuserBuckets\n  \n\n\nAllocation Strategies\n\n\nAllocation Strategies specify how to earn interest from a decentralized finance liquidity pools and how to track the correct rToken balance, including both the original principal amount and the amount of interest that is redirected.\n\n\nEach Allocation Strategy is customized to the mechanics of a particular decentralized liquidity protocol that allows holders of underlying ERC20 assets to earn interest. Currently rToken allocation strategies have been written for Compound and Aave. \n\n\nCreating an Allocation Strategy\n\n\nWhitelisting an Allocation Strategy\n\n\n\n\nSwitchboard Registry\n\n\nHats are created, stored and modified in a registry contract called Switchboard.sol.  \n\n\nAny rToken may be used with any hat, provided its underlying asset (e.g. DAI, SNX, etc) is available on the hat's allocation strategy platform.\n\n\nCreating a New Hat\n\n\nAnyone can create a new hat by calling \ncreateHat\n and passing \naddress[] recipients\n \nuint256[] proportions\n \naddress(enum?) allocationStrategy\n and \naddress manager\n.\n\n\nCreated hats are assigned a sequential immutable \nhatID\n. Hats cannot be deleted.\n\n\nModifying a Hat\n\n\nThe \nmanager\n address has the power to modify the hat's parameters, including by changing the \nmanager\n which transfers control of the hat. \n\n\nModifications to a hat emit the HatModified event.\n\n\nmodifyHat(uint256 hatID, address[] memory recipients, uint256[] memory proportions, address (enum?) allocationStrategy, address manager) external onlyManager returns (bool)\n[TBD: Is there a gas savings reason to split this function into three or four separate functions like modifyHatRecipients, modifyHatProportions, modifyHatStrategy, modifyHatManager?)",
            "title": "Elements"
        },
        {
            "location": "/elements/#elements",
            "text": "",
            "title": "Elements"
        },
        {
            "location": "/elements/#rtokens",
            "text": "rTokens are wrapped versions of underlying ERC20 assets that earn interest that can be redirected to flow to recipients that the holder of the underlying asset chooses.  The rToken contract keeps track of the total amount of minted rTokens, user balances, and User Buckets.",
            "title": "rTokens"
        },
        {
            "location": "/elements/#deployment",
            "text": "At deployment, an rToken contract must specify the address of the underlying ERC20 asset. To be useful as an rToken, the underlying ERC20 asset should be available to supply on one or more  platforms for which an Allocation Strategy has been written to manage and redirect interest.",
            "title": "Deployment"
        },
        {
            "location": "/elements/#rtoken-accounts",
            "text": "Each address has an rToken Account. The account data includes: userBuckets  \u2013 an array specifying the amounts of rTokens committed to each active  hatID \ninternal accounting information,\naccount statistics.",
            "title": "rToken Accounts"
        },
        {
            "location": "/elements/#minting",
            "text": "rTokens are minted and redeemed at a ratio of 1:1 to their underlying asset. So 25 DAI can mint 25 rDAI, which are then redeemable for 25 DAI.  Like other ERC20 wrapper contracts, rToken contracts require holders of the underlying asset to  approve  the amount of the asset to be used to mint rTokens. This amount can be queried with  allowance .  There are three minting functions:    mint(uint256 amount)  -     mintWithSelectedHat(uint256 amount uint256 hatID)  -",
            "title": "Minting"
        },
        {
            "location": "/elements/#control-over-interest-streams",
            "text": "The holder of the underlying asset remains in control of where the interest streams flow, but cannot claw back interest that has already been redirected. The holder can stop sending interest to a recipient (or recipients) by: 1) redeeming all the principal for the underlying asset or 2) changing the set of recipients with the  changeHat  function.",
            "title": "Control Over Interest Streams"
        },
        {
            "location": "/elements/#accounting-construct",
            "text": "rTokens work by recording the amount of the underlying asset that an address mints (the principal) as a fixed debt that must be repaid, and then \u201clending\u201d out the now interest earning principal to the interest recipients. The recipients can redeem the amount of rTokens that have accrued from interest, but they cannot redeem the debt portion which represents the principal.  Example   Alice mints 1,000 rDAI and designates Bob as the only interest recipient.   At that time Bob has received a loan of 1,000 rDAI and a debt to repay 1,000 rDAI to Alice, meaning a net position of 0 rDAI.    If Bob calls redeemAll() to try to get all the underlying DAI, he will not receive anything because he can only redeem the amount in excess of the debt.   Now fast forward to a time when 75 DAI in interest has accumulated. Bob's \u201cloan\u201d is now worth 1,075 DAI but his debt remains 1,000 DAI, so he can redeem 75 DAI.",
            "title": "Accounting Construct"
        },
        {
            "location": "/elements/#common-write-functions",
            "text": "",
            "title": "Common write functions"
        },
        {
            "location": "/elements/#initialize",
            "text": "initialize(address underlyingAsset, string memory name_, string memory symbol_, uint256 decimals_) public  \u2013 set the parameters of an rToken at deployment",
            "title": "Initialize"
        },
        {
            "location": "/elements/#approve",
            "text": "approve(address owner address spender) external public returns (bool)  - allow rToken minting from underlying ERC20 asset",
            "title": "Approve"
        },
        {
            "location": "/elements/#minting_1",
            "text": "mint(uint256 mintAmount) external nonReentrant returns (bool)  - swap underlying asset for rTokens at 1:1 ratio, e.g.  mint  100 rDAI from 100 DAI - by default, will send interest to minter's address     mintWithSelectedHat(uint256 mintAmount, uint256 hatID) external nonReentrant returns (bool)  - mint rTokens into specified  hatID      mintWithNewHat(uint256 mintAmount, address[] calldata recipients, uint32[] calldata proportions) external nonReentrant returns (bool)  - create a new hat and mint rTokens into that  hatID    NEW FOR V2  mintWithUserBuckets(uint256 mintAmount) external nonReentrant returns (bool)  - same as  mint  except the newly minted rTokens will increase all  userBucket  balances proportionally - can be gas-inefficient",
            "title": "Minting"
        },
        {
            "location": "/elements/#redemption",
            "text": "redeem(uint256 redeemAmount) external nonReentrant returns (bool)  - redeem specified rTokens for underlying ERC20 asset at 1:1 ratio    redeemAll() external nonReentrant returns (bool)  - redeem all rTokens for underlying ERC20 asset at 1:1 ratio",
            "title": "Redemption"
        },
        {
            "location": "/elements/#transfers",
            "text": "transfer(address dst, uint256 amount) external nonReentrant returns (bool)  - standard ERC20 transfer function      transferAll(address dst) external nonReentrant returns (bool)  - standard ERC20 transferAll function - can be gas inefficient if userBuckets include multiple allocation strategies",
            "title": "Transfers"
        },
        {
            "location": "/elements/#claiming-accrued-interest",
            "text": "payInterest(address )",
            "title": "Claiming Accrued Interest"
        },
        {
            "location": "/elements/#changing-hats",
            "text": "changeHatForBucket(uint256 newHatID, uint32 bucket) external nonReentrant returns (bool)    changeHatForAllBuckets(uint256 newHatID) external nonReentrant returns (bool)",
            "title": "Changing Hats"
        },
        {
            "location": "/elements/#common-read-functions",
            "text": "getHatsByAddress(address owner) external view returns (hats[])    getBucketsByAddress(address owner) external view returns (userBuckets[])    receivedSavingsOf(address owner) external view returns (uint256 amount)    receivedLoanOf(address owner) external view returns (uint256 amount)    interestPayableOf(address owner) external view returns (uint256 amount)    getUnderlyingAsset() public view returns (address)    balanceOf(address owner) external view returns (uint256 amount)    allowance(address owner, address spender) external view returns (uint256)",
            "title": "Common read functions"
        },
        {
            "location": "/elements/#hats",
            "text": "Hats contain the instructions for where to generate and redirect the interest on rTokens. Each hat specifies to which addresses the interest should flow and in what proportions, where the underlying asset should be invested to earn interest, and if the hat can be changed, by who. \nHats are ERC721 NFTs.",
            "title": "Hats"
        },
        {
            "location": "/elements/#hat-parameters",
            "text": "A hat contains the following four parameters:  recipients  - an array of up to 50 addresses where the interest should flow  proportions  - an array specifying the proportion of the interest each recipient should receive \u2013 this array must have the same length as  recipients  allocationStrategy  - an address (enum?) specifying the liquidity pool to deposit the underlying asset to earn interest from (e.g. Compound, Aave, etc)  manager  - an address specifying who can modify the hat's parameters \u2013 can be set to the 0x000... address to make a hat immutable  The parameters  recipients  and  proportions  are the central programmable components of rToken interest. The number of recipients in a hat can be just one or up to 50 (this maximum number is there to avoid a possible out-of-gas reversion error).  Proportions can be set arbitrarily and the contract will allocate the interest as a proportion of the maximum uint32 number (4,294,967,295 in decimal), so if the proportions entered were  [1, 2, 3, 4] meaning the fourth recipient received 4x the interest as the first, the  proportions  stored on chain would be [429496730, 858993459, 1288490188, 1717986918].  The  allocationStrategy  parameter points to the address of the deployed contract that invests the underlying asset in a particular lending protocol, such as Compound's cTokens or Aave's aTokens.   The  manager  parameter will typically be the creator of a hat that others might want to use, such as a charity dapp.  The manager has the power to modify the other three parameters of the hat -  recipients   proportions  and  allocationStrategy  - pursuant to the rules surrounding modifying hats (link).   None of the hat parameters are exclusive, either separately or together \u2013 there are no squatter's rights to being the first manager for a potentially popular combination of  recipients ,  proportions  and  allocationStrategy.",
            "title": "Hat Parameters"
        },
        {
            "location": "/elements/#changeable-hats",
            "text": "Changeable hats have several substantive use cases, including allowing trusted dapp managers to be able to redirect interest to better serve their users' ends, to swap out of an underperforming lending pool to obtain higher yields or to switch to a more stable/liquid lending pool.rToken-powered dapps would otherwise require each user to manually change hats whenever it recommended a different set of parameters.  Changeable hats do introduce a potential for abuse by the managers, but because changes are emitted as events, malicious managers cannot act in stealth, nor do they have any control over the holder's principal assets, only forward looking interest streams.",
            "title": "Changeable Hats"
        },
        {
            "location": "/elements/#immutable-hats",
            "text": "There may be use cases where hat immutability is desirable to prevent the possibility of mismanagement. Immutable hats can be created by assigning the burn address (0x0000000000000000000000000000000000000000) in the  manager  parameter.",
            "title": "Immutable Hats"
        },
        {
            "location": "/elements/#user-buckets",
            "text": "User Buckets, added for rToken V2, are tranches of rTokens assigned to a particular Hat. A bucket can contain some or all of the user's rToken balance.  Buckets are a design solution to the \u201chat yanking\u201d problem described here[https://medium.com/rtoken-project/rdai-v2-the-redirectening-90b6a9115799].    Each rToken holder has a  userBuckets  array with each slot specifying the  hatID  and the  amount  of the rToken used in that Hat. The first array position (slot 0) is reserved as a self-hat that redirects the interest to the user, similar to directly lending assets in a liquidity pool.   User Buckets are created and maintained automatically within the rToken contract.  Example   Assume Alice mints 100 rDAI, and donates the interest on 40 rDAI to Charity X.   Her  userBuckets  array now contains two slots, with the self-hat slot 0 holding  amount: 60  and slot 1 pointing to  hatID: [Hat with Charity X address]  holding  amount: 40 .   Later Alice decides to send the interest on the remaining 60 rDAI to Charity Y.    Now  userBuckets  has three slots with  amount  0, 40 and 60 respectively.  [TBD: when a user redeems the amount in a bucket, is that  userBuckets  array slot deleted  or preserved with a 0  amount ? Preserving old buckets might lead to state bloat, but might be useful for historical accounting purposes. Deleting buckets could reduce state size, but may lead to complications if dapps or other entities seek to query particular hat/bucket data based on slot position]",
            "title": "User Buckets"
        },
        {
            "location": "/elements/#common-read-functions_1",
            "text": "getUserBuckets(address owner) public view returns []  - returns an array containing the address'  userBuckets",
            "title": "Common read functions"
        },
        {
            "location": "/elements/#allocation-strategies",
            "text": "Allocation Strategies specify how to earn interest from a decentralized finance liquidity pools and how to track the correct rToken balance, including both the original principal amount and the amount of interest that is redirected.  Each Allocation Strategy is customized to the mechanics of a particular decentralized liquidity protocol that allows holders of underlying ERC20 assets to earn interest. Currently rToken allocation strategies have been written for Compound and Aave.",
            "title": "Allocation Strategies"
        },
        {
            "location": "/elements/#creating-an-allocation-strategy",
            "text": "",
            "title": "Creating an Allocation Strategy"
        },
        {
            "location": "/elements/#whitelisting-an-allocation-strategy",
            "text": "",
            "title": "Whitelisting an Allocation Strategy"
        },
        {
            "location": "/elements/#switchboard-registry",
            "text": "Hats are created, stored and modified in a registry contract called Switchboard.sol.    Any rToken may be used with any hat, provided its underlying asset (e.g. DAI, SNX, etc) is available on the hat's allocation strategy platform.",
            "title": "Switchboard Registry"
        },
        {
            "location": "/elements/#creating-a-new-hat",
            "text": "Anyone can create a new hat by calling  createHat  and passing  address[] recipients   uint256[] proportions   address(enum?) allocationStrategy  and  address manager .  Created hats are assigned a sequential immutable  hatID . Hats cannot be deleted.",
            "title": "Creating a New Hat"
        },
        {
            "location": "/elements/#modifying-a-hat",
            "text": "The  manager  address has the power to modify the hat's parameters, including by changing the  manager  which transfers control of the hat.   Modifications to a hat emit the HatModified event.  modifyHat(uint256 hatID, address[] memory recipients, uint256[] memory proportions, address (enum?) allocationStrategy, address manager) external onlyManager returns (bool)\n[TBD: Is there a gas savings reason to split this function into three or four separate functions like modifyHatRecipients, modifyHatProportions, modifyHatStrategy, modifyHatManager?)",
            "title": "Modifying a Hat"
        },
        {
            "location": "/interest/",
            "text": "Interest\n\n\n\n\nrTokens do not automatically increment token balances as interest accrues. Token balances in Ethereum can only be updated through transactions. But there is a way to query the amount of accrued interest: \ninterestPayableOf\n. \n\n\nQuerying Accrued Interest\n\n\nTo understand what is happening with interest and how to claim it, there are two values that should be queried for each address: \n\n\n\n\n\n\nrToken \nbalanceOf\n - for minters, this will be equal to the amount of the underlying ERC20 asset principal plus the amount claimed through the \npayInterest\n function, for recipients this value will be 0 until the \npayInterest\n function is called, which updates \nbalanceOf\n\n\n\n\n\n\ninterestPayableOf\n - this is the amount of accrued interest that may be claimed by the address\n\n\n\n\n\n\nTo illustrate what's going on when, let's look at a simple example where Alice mints 100 rDAI to the self hat (meaning she \u201credirects\u201d all the interest to herself), accrues 8 rDAI in interest and then claims it.\n\n\n\n\nThe illustration above shows each step, but a more efficient flow would call \nredeemAll\n after the 8 rDAI have accrued, which calls \npayInterest\n internally:\n\n\n\nClaiming Accrued Interest",
            "title": "Interest"
        },
        {
            "location": "/interest/#interest",
            "text": "rTokens do not automatically increment token balances as interest accrues. Token balances in Ethereum can only be updated through transactions. But there is a way to query the amount of accrued interest:  interestPayableOf .",
            "title": "Interest"
        },
        {
            "location": "/interest/#querying-accrued-interest",
            "text": "To understand what is happening with interest and how to claim it, there are two values that should be queried for each address:     rToken  balanceOf  - for minters, this will be equal to the amount of the underlying ERC20 asset principal plus the amount claimed through the  payInterest  function, for recipients this value will be 0 until the  payInterest  function is called, which updates  balanceOf    interestPayableOf  - this is the amount of accrued interest that may be claimed by the address    To illustrate what's going on when, let's look at a simple example where Alice mints 100 rDAI to the self hat (meaning she \u201credirects\u201d all the interest to herself), accrues 8 rDAI in interest and then claims it.   The illustration above shows each step, but a more efficient flow would call  redeemAll  after the 8 rDAI have accrued, which calls  payInterest  internally:",
            "title": "Querying Accrued Interest"
        },
        {
            "location": "/interest/#claiming-accrued-interest",
            "text": "",
            "title": "Claiming Accrued Interest"
        },
        {
            "location": "/overview/",
            "text": "Overview\n\n\n\n\nThe rToken system is a programmable interest engine that generates and redirects yields on ERC20 assets using decentralized finance protocols.\n\n\nThe rToken system has four key elements:\n\n\n1. rTokens\n - instantiated ERC20 wrappers for underlying ERC20 assets like DAI that are invested in interest generating DeFi protocols and that allow their holders to program where the interest should flow\n\n\n2. Hats\n \u2013 instructions specifying where the underlying ERC20 asset should be invested to earn interest, who should receive that interest and in what proportions. All rTokens must have a hat.\n\n\n3. User Buckets\n \u2013 user-specific tranches of rTokens that are used in the same hat\n\n\n4. Allocation Strategies (Yield Strategies?)\n \u2013 sources of interest generated by decentralized finance protocols   \n\n\nInterest flows are programmed through a set of instructions called \u201chats\u201d that users assign to particular buckets (amounts) of rTokens.  The allocation strategy specifies where the interest will be earned. \n\n\nFor instance a user with 100 DAI could mint 40 rDAI in bucket 1 that sends interest earned on Compound to Charity A and mint 60 rDAI in bucket 2 that sends interest earned on Aave to Charity B.\n\n\nHere's an illustrative example:\n\n\n\n\n\n\nAlice holds 200 DAI and sees that an rToken called rDAI exists that allows her to redirect interest earned from Compound (via an Allocation Strategy) to whatever addresses she chooses. \n\n\n\n\n\n\nShe decides to mint 80 rDAI and creates a new hat to send the interest to her friend Bob as a gesture of goodwill.  \n\n\n\n\n\n\nAlice then visits a dapp that allows her to send the interest generated on her DAI from the aave protocol to Charity X, which she supports. She decides to activate her remaining 120 DAI for this purpose.\n\n\n\n\n\n\nNow Alice has 200 rDAI, from which she is sending the interest on 80 to Bob in Bucket 1 and the interest on 120 to Charity X in Bucket 2.  \n\n\n\n\n\n\nAlice keeps a claim on her 200 DAI as rDAI and can redeem it in part or in whole whenever she wishes.   \n\n\n\n\n\n\n            +------+\n      +-----+ User +-------+\n      |     +------+       |\n      |                    |\n      |                    |                      +-----------------------+\n      |                    |                      |compound.finance cToken|\n +----+-----+  +-----------+-----------+          +-----------------------+\n |  Dapp    |  |ERC20 Compatible Wallet|                     ^\n +----+-----+  +-----------+-----------+                     |\n      |                    |                     +--------------------------+\n      |                    |                     |CompoundAllocationStrategy|\n      |                    |                     +--------------------------+\n      |                    |                                 ^\n      |                    v                                 |\n      |    +----------------------------------+              |\n      |    |          RToken                  |              |\n      |    |----------------------------------|              |\n      |    | - ERC20 compatible               |              |\n      +--->| - Mint/Redeem/PayInterest        |              |\n           | - \"Hat\"/\"Bucket\"                 |              |\n           | - Changeable allocation strategy +--------------+\n           | - Configurable parameters        | IAllocationStrategy interface\n           | - Admin role (human/DAO)         |\n           +----------------------------------+\n                       ^\n                       |\n                    +--+--+\n                    |Admin|\n                    +-----+",
            "title": "Overview"
        },
        {
            "location": "/overview/#overview",
            "text": "The rToken system is a programmable interest engine that generates and redirects yields on ERC20 assets using decentralized finance protocols.  The rToken system has four key elements:  1. rTokens  - instantiated ERC20 wrappers for underlying ERC20 assets like DAI that are invested in interest generating DeFi protocols and that allow their holders to program where the interest should flow  2. Hats  \u2013 instructions specifying where the underlying ERC20 asset should be invested to earn interest, who should receive that interest and in what proportions. All rTokens must have a hat.  3. User Buckets  \u2013 user-specific tranches of rTokens that are used in the same hat  4. Allocation Strategies (Yield Strategies?)  \u2013 sources of interest generated by decentralized finance protocols     Interest flows are programmed through a set of instructions called \u201chats\u201d that users assign to particular buckets (amounts) of rTokens.  The allocation strategy specifies where the interest will be earned.   For instance a user with 100 DAI could mint 40 rDAI in bucket 1 that sends interest earned on Compound to Charity A and mint 60 rDAI in bucket 2 that sends interest earned on Aave to Charity B.  Here's an illustrative example:    Alice holds 200 DAI and sees that an rToken called rDAI exists that allows her to redirect interest earned from Compound (via an Allocation Strategy) to whatever addresses she chooses.     She decides to mint 80 rDAI and creates a new hat to send the interest to her friend Bob as a gesture of goodwill.      Alice then visits a dapp that allows her to send the interest generated on her DAI from the aave protocol to Charity X, which she supports. She decides to activate her remaining 120 DAI for this purpose.    Now Alice has 200 rDAI, from which she is sending the interest on 80 to Bob in Bucket 1 and the interest on 120 to Charity X in Bucket 2.      Alice keeps a claim on her 200 DAI as rDAI and can redeem it in part or in whole whenever she wishes.                   +------+\n      +-----+ User +-------+\n      |     +------+       |\n      |                    |\n      |                    |                      +-----------------------+\n      |                    |                      |compound.finance cToken|\n +----+-----+  +-----------+-----------+          +-----------------------+\n |  Dapp    |  |ERC20 Compatible Wallet|                     ^\n +----+-----+  +-----------+-----------+                     |\n      |                    |                     +--------------------------+\n      |                    |                     |CompoundAllocationStrategy|\n      |                    |                     +--------------------------+\n      |                    |                                 ^\n      |                    v                                 |\n      |    +----------------------------------+              |\n      |    |          RToken                  |              |\n      |    |----------------------------------|              |\n      |    | - ERC20 compatible               |              |\n      +--->| - Mint/Redeem/PayInterest        |              |\n           | - \"Hat\"/\"Bucket\"                 |              |\n           | - Changeable allocation strategy +--------------+\n           | - Configurable parameters        | IAllocationStrategy interface\n           | - Admin role (human/DAO)         |\n           +----------------------------------+\n                       ^\n                       |\n                    +--+--+\n                    |Admin|\n                    +-----+",
            "title": "Overview"
        }
    ]
}